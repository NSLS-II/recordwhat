from ophyd import (EpicsSignal, EpicsSignalRO)

from .. import (RecordBase, _register_record_type,
                FieldComponent as Cpt)


@_register_record_type('asyn')
class AsynRecord(RecordBase):
    abort_queuerequest = Cpt(EpicsSignal, '.AQR')
    alarm_status = Cpt(EpicsSignalRO, '.STAT')
    eom_reason = Cpt(EpicsSignalRO, '.EOMR')
    input_response_string = Cpt(EpicsSignalRO, '.AINP$')
    input_binary_data = Cpt(EpicsSignal, '.BINP')
    number_of_bytes_actually_written = Cpt(EpicsSignal, '.NAWT')
    number_of_bytes_read = Cpt(EpicsSignalRO, '.NORD')
    output_binary_data = Cpt(EpicsSignal, '.BOUT')
    port_connect_disconnect = Cpt(EpicsSignal, '.PCNCT')
    serial_poll_response = Cpt(EpicsSignalRO, '.SPR')
    translated_input_string = Cpt(EpicsSignalRO, '.TINP$')
    asynfloat64_input = Cpt(EpicsSignalRO, '.F64INP')
    asynfloat64_is_valid = Cpt(EpicsSignal, '.F64IV')
    asyngpib_is_valid = Cpt(EpicsSignal, '.GPIBIV')
    asynint32_input = Cpt(EpicsSignalRO, '.I32INP')
    asynint32_is_valid = Cpt(EpicsSignal, '.I32IV')
    asynoctet_is_valid = Cpt(EpicsSignal, '.OCTETIV')
    asynoption_is_valid = Cpt(EpicsSignal, '.OPTIONIV')
    asynuint32digital_input = Cpt(EpicsSignalRO, '.UI32INP')
    asynuint32digital_is_valid = Cpt(EpicsSignal, '.UI32IV')
    asynuser_reason = Cpt(EpicsSignal, '.REASON')

    # - display
    trace_io_mask = Cpt(EpicsSignal, '.TIOM')
    trace_io_ascii = Cpt(EpicsSignal, '.TIB0')
    trace_io_device = Cpt(EpicsSignal, '.TB1')
    trace_io_driver = Cpt(EpicsSignal, '.TB3')
    trace_io_escape = Cpt(EpicsSignal, '.TIB1')
    trace_io_file = Cpt(EpicsSignal, '.TFIL$')
    trace_io_filter = Cpt(EpicsSignal, '.TB2')
    trace_io_hex = Cpt(EpicsSignal, '.TIB2')
    trace_io_truncate_size = Cpt(EpicsSignal, '.TSIZ')
    trace_info_port = Cpt(EpicsSignal, '.TINB1')
    trace_info_source = Cpt(EpicsSignal, '.TINB2')
    trace_info_thread = Cpt(EpicsSignal, '.TINB3')
    trace_info_time = Cpt(EpicsSignal, '.TINB0')
    trace_info_mask = Cpt(EpicsSignal, '.TINM')
    trace_error = Cpt(EpicsSignal, '.TB0')
    trace_flow = Cpt(EpicsSignal, '.TB4')
    trace_mask = Cpt(EpicsSignal, '.TMSK')
    trace_warning = Cpt(EpicsSignal, '.TB5')

    # - inputs
    autoconnect = Cpt(EpicsSignal, '.AUCT')
    baud_rate = Cpt(EpicsSignal, '.BAUD')
    baud_rate_lbaud = Cpt(EpicsSignal, '.LBAUD')
    connect_disconnect = Cpt(EpicsSignal, '.CNCT')
    data_bits = Cpt(EpicsSignal, '.DBIT')
    driver_info_string = Cpt(EpicsSignal, '.DRVINFO$')
    enable_disable = Cpt(EpicsSignal, '.ENBL')
    flow_control = Cpt(EpicsSignal, '.FCTL')
    input_delimiter = Cpt(EpicsSignal, '.IEOS$')
    input_xon_xoff = Cpt(EpicsSignal, '.IXOFF')
    input_format = Cpt(EpicsSignal, '.IFMT')
    interface = Cpt(EpicsSignal, '.IFACE')
    max_size_of_input_array = Cpt(EpicsSignalRO, '.IMAX')
    modem_control = Cpt(EpicsSignal, '.MCTL')
    number_of_bytes_to_read = Cpt(EpicsSignal, '.NRRD')
    output_xon_xoff = Cpt(EpicsSignal, '.IXON')
    parity = Cpt(EpicsSignal, '.PRTY')
    stop_bits = Cpt(EpicsSignal, '.SBIT')
    timeout_sec = Cpt(EpicsSignal, '.TMOT')
    transaction_mode = Cpt(EpicsSignal, '.TMOD')
    xon_any_character = Cpt(EpicsSignal, '.IXANY')
    asyn_address = Cpt(EpicsSignal, '.ADDR')
    asyn_port = Cpt(EpicsSignal, '.PORT$')

    # - output
    addressed_command = Cpt(EpicsSignal, '.ACMD')
    max_size_of_output_array = Cpt(EpicsSignalRO, '.OMAX')
    number_of_bytes_to_write = Cpt(EpicsSignal, '.NOWT')
    output_command_string = Cpt(EpicsSignal, '.AOUT$')
    output_delimiter = Cpt(EpicsSignal, '.OEOS$')
    output_format = Cpt(EpicsSignal, '.OFMT')
    universal_command = Cpt(EpicsSignal, '.UCMD')
    asynfloat64_output = Cpt(EpicsSignal, '.F64OUT')
    asynint32_output = Cpt(EpicsSignal, '.I32OUT')
    asynuint32digital_mask = Cpt(EpicsSignal, '.UI32MASK')
    asynuint32digital_output = Cpt(EpicsSignal, '.UI32OUT')
